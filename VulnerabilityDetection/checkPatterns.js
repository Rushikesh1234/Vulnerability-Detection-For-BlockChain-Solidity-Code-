const jsonpath = require('jsonpath')
const { JSONPath } = require('jsonpath-plus')
const chalk = require('chalk')

module.exports = {
    detectOutdatedCompilerVersion: (parseTree) => {
        let outdatedPragmaDirective = {}
        const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
        if (pragmaDirective.length !== 1) {
            return {
                error: 'Smart contract must contain exactly one pragma statement.'
            }
        } else if (pragmaDirective[0].value !== '^0.8.9' && pragmaDirective[0].value !== '0.8.9') {
            outdatedPragmaDirective = pragmaDirective[0]
        }
        return outdatedPragmaDirective
    },

    detectFloatingPragma: (parseTree) => {
        let floatingPragmaDirective = {}
        const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
        if (pragmaDirective.length !== 1) {
            return {
                error: 'Smart contract must contain exactly one pragma statement.'
            }
        } else if (pragmaDirective[0].value.includes('^')) {
            floatingPragmaDirective = pragmaDirective[0]
        }
        return floatingPragmaDirective
    },

    detectTransferAndSend: (parseTree) => {
        const transferOrSendCalls = []
        const functionDefinitions = jsonpath.query(parseTree, '$..subNodes[?(@.type=="FunctionDefinition")]')
        functionDefinitions.forEach((funcDef) => {
            const statements = jsonpath.query(funcDef, '$.body.statements')[0]
            statements.forEach((statement) => {
                const detectedCalls = jsonpath.query(statement, '$..[?(@.memberName=="transfer" || @.memberName=="send")]')
                if (detectedCalls.length > 0) {
                    transferOrSendCalls.push(detectedCalls)
                }
            })
        })
        return transferOrSendCalls
    },


    detectUncheckedCallReturnValue: (parseTree) => {
        let uncheckedCallReturnValues = []
        // Vulnerability patterns for Unchecked Call Return Value
        const uncheckedStatements = '$..statements[?(@.type != "IfStatement" && @.type != "ReturnStatement" && ' +
            '@.type != "VariableDeclarationStatement")]'
        const lowLevelFunctionCalls = '$..expression[?(@.type != "FunctionCall" && (@.memberName == "call" || @.memberName == "send" || ' +
            '@.memberName == "delegatecall" || @.memberName == "callcode"))]'

        // JSON Queries for pattern matching
        const q1 = JSONPath({
            json: parseTree,
            path: uncheckedStatements,
            resultType: 'value'
        })
        const q2 = JSONPath({
            json: q1,
            path: lowLevelFunctionCalls,
            resultType: 'value'
        })
        uncheckedCallReturnValues = q2

        return uncheckedCallReturnValues
    },

    detectTXOrigin: (parseTree) => {
        const txOrigin = []
        const requireStatementQuery = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?((@.type == "ExpressionStatement") && (@.expression.type == "FunctionCall") && (@.expression.expression.name == "require"))].expression.arguments')
        for (let i = 0; i < requireStatementQuery.length; i++) {
          const requireStatement = requireStatementQuery[i]
          if (requireStatement.length > 0) {
            const inRequire = jsonpath.query(requireStatement, '$..[?( (@.type == "BinaryOperation") && (@.operator == "==") && (@.left.expression.name == "tx") && (@.left.memberName == "origin") )]')
            if (inRequire.length > 0) {
              txOrigin.push(requireStatement)
            }
          }
        }
        return txOrigin
    }
}