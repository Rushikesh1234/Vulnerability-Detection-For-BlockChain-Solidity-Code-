const checkPatterns = require('./checkPatterns')
const chalk = require('chalk')

module.exports = {
    checkPatterns: (parseData) => {

        flag = 0

        outdatedCompilerVersion = checkPatterns.detectOutdatedCompilerVersion(parseData)
        console.log(outdatedCompilerVersion)
        outdatedCompilerVersion_Counter = outdatedCompilerVersion.length
        outdatedCompilerVersion_Mitigation = '1. Edit the smart contract’s pragma directive to specify the most recent release of the Solidity compiler (currently v0.8.10). \n 2. Suggested pragma directive: `pragma solidity 0.8.9'
        if (outdatedCompilerVersion_Counter != 0) {
            printData('OutdatedCompilerVersion', outdatedCompilerVersion_Counter, 'LOW', outdatedCompilerVersion, outdatedCompilerVersion_Mitigation)
            flag = 1
        }

        floatingPragma = checkPatterns.detectFloatingPragma(parseData)
        floatingPragma_Counter = floatingPragma.length
        floatingPragma_Mitigation = '1. Lock the smart contract’s pragma directive to a specific compiler version (preferably the latest release) by removing the “^” character from the specified compiler version. \n 2. Suggested pragma directive: `pragma solidity 0.8.9.'
        if (floatingPragma_Counter != 0) {
            printData('FloatingPragma', floatingPragma_Counter, 'LOW', floatingPragma, floatingPragma_Mitigation)
            flag = 1
        }

        transferAndSend = checkPatterns.detectTransferAndSend(parseData)
        transferAndSend_Counter = transferAndSend.length
        transferAndSend_Mitigation = '1. It is now recommended that you utilize call{ value: x }() instead of the transfer() or send() functions, which forward a fixed gas amount.'
        if (transferAndSend_Counter != 0) {
            printData('TransferAndSend', transferAndSend_Counter, 'MEDIUM', transferAndSend, transferAndSend_Mitigation)
            flag = 1
        }

        uncheckedCallReturnValue = checkPatterns.detectUncheckedCallReturnValue(parseData)
        uncheckedCallReturnValue_Counter = uncheckedCallReturnValue.length
        uncheckedCallReturnValue_Mitigation = '1. Recommended that if you choose to use low-level call methods (e.g., address.call(), address.callcode(), address.delegatecall(), and address.send()), check the return value to handle potential call failures.'
        if (uncheckedCallReturnValue_Counter != 0) {
            printData('UncheckedCallReturnValue', uncheckedCallReturnValue_Counter, 'HIGH', uncheckedCallReturnValue, uncheckedCallReturnValue_Mitigation)
            flag = 1
        }

        txOrigin = checkPatterns.detectTXOrigin(parseData)
        txOrigin_Counter = txOrigin.length
        txOrigin_Mitigation = '1. To authenticate the sender of a transaction, use msg.sender instead of the tx.origin global variable.'
        if (txOrigin_Counter != 0) {
            printData('TxOrigin', txOrigin_Counter, 'HIGH', txOrigin, txOrigin_Mitigation)
            flag = 1
        }

        if(flag == 0) {
            console.log(chalk.green('No issues found in File. All Good.'))
        }
    }
}

function printData(vulnerabilityName, count, severity, vulnerabilityDetail, mitigation) {

    console.log('\n')
    console.log(chalk.green.underline.bold(vulnerabilityName))

    if (severity == 'HIGH') {
        console.log(chalk.white('Severity Level - '+ chalk.red(severity)))
    } else if (severity == 'MEDIUM') {
        console.log(chalk.white('Severity Level - '+ chalk.yellow(severity)))
    } else {
        console.log(chalk.white('Severity Level - '+ chalk.green(severity)))
    }

    console.log(chalk.white('Found Instance - ' + chalk.yellow(count)))

    console.log(chalk.blue(vulnerabilityDetail))

    console.log(chalk.magentaBright('Suggestion to fix vulnerability -'))
    console.log(chalk.magentaBright(mitigation))
}