const checkPatterns = require('./checkPatterns')
const generateReport = require('./generateReport')
const chalk = require('chalk')
const prettier = require("prettier");
const readline = require('readline');

var pdfData = []
var tableData = []
var printConsoleData = []

module.exports = {
    checkPatterns: (parseData) => {

        index = 1
        flag = 0

        outdatedCompilerVersion = checkPatterns.detectOutdatedCompilerVersion(parseData)
        outdatedCompilerVersion_Counter = 1
        outdatedCompilerVersion_Mitigation = '1. Edit the smart contract’s pragma directive to specify the most recent release of the Solidity compiler (currently v0.8.10). \n2. Suggested pragma directive: `pragma solidity 0.8.9'
        if (outdatedCompilerVersion_Counter > 0) {
            printData(index, 'Outdated Compiler Version', outdatedCompilerVersion_Counter, 'LOW', outdatedCompilerVersion, outdatedCompilerVersion_Mitigation)
            flag = 1
            index++
        }

        floatingPragma = checkPatterns.detectFloatingPragma(parseData)
        floatingPragma_Counter = 1
        floatingPragma_Mitigation = '1. Lock the smart contract’s pragma directive to a specific compiler version (preferably the latest release) by removing the “^” character from the specified compiler version. \n2. Suggested pragma directive: `pragma solidity 0.8.9.'
        if (floatingPragma_Counter > 0) {
            printData(index, 'Floating Pragma', floatingPragma_Counter, 'LOW', floatingPragma, floatingPragma_Mitigation)
            flag = 1
            index++
        }

        transferAndSend = checkPatterns.detectTransferAndSend(parseData)
        transferAndSend_Counter = transferAndSend.length
        transferAndSend_Mitigation = '1. It is now recommended that you utilize call{ value: x }() instead of the transfer() or send() functions, which forward a fixed gas amount.'
        if (transferAndSend_Counter > 0) {
            printData(index, 'Transfer And Send', transferAndSend_Counter, 'MEDIUM', transferAndSend, transferAndSend_Mitigation)
            flag = 1
            index++
        }

        uncheckedCallReturnValue = checkPatterns.detectUncheckedCallReturnValue(parseData)
        uncheckedCallReturnValue_Counter = uncheckedCallReturnValue.length
        uncheckedCallReturnValue_Mitigation = '1. Recommended that if you choose to use low-level call methods (e.g., address.call(), address.callcode(), address.delegatecall(), and address.send()), check the return value to handle potential call failures.'
        if (uncheckedCallReturnValue_Counter > 0) {
            printData(index, 'Unchecked Call Return Value', uncheckedCallReturnValue_Counter, 'HIGH', uncheckedCallReturnValue, uncheckedCallReturnValue_Mitigation)
            flag = 1
            index++
        }

        txOrigin = checkPatterns.detectTXOrigin(parseData)
        txOrigin_Counter = txOrigin.length
        txOrigin_Mitigation = '1. To authenticate the sender of a transaction, use msg.sender instead of the tx.origin global variable.'
        if (txOrigin_Counter > 0) {
            printData(index, 'Tx Origin', txOrigin_Counter, 'HIGH', txOrigin, txOrigin_Mitigation)
            flag = 1
            index++
        }

        if (flag == 0) {
            console.log(chalk.green('No issues found in File. All Good.'))
        }

        console.table(tableData)

        for(var i=0; i<printConsoleData.length; i++) {
            console.log('\n')
            console.log(chalk.green.underline.bold(printConsoleData[i].VulnerabilityName))

            if (printConsoleData[i].SeverityLevel == 'HIGH') {
                console.log(chalk.white('Severity Level - ' + chalk.red(printConsoleData[i].SeverityLevel)))
            } else if (printConsoleData[i].SeverityLevel == 'MEDIUM') {
                console.log(chalk.white('Severity Level - ' + chalk.yellow(printConsoleData[i].SeverityLevel)))
            } else {
                console.log(chalk.white('Severity Level - ' + chalk.green(printConsoleData[i].SeverityLevel)))
            }

            console.log(chalk.white('Found Instance - ' + chalk.yellow(printConsoleData[i].FoundInstance)))

            // console.log(chalk.blue(prettier.format(JSON.stringify(vulnerabilityDetail), {semi: false, parser: "json"})))
            console.log(chalk.blue(JSON.stringify(printConsoleData[i].VulnerabilityDetails, null, 0)))

            console.log(chalk.magentaBright('Suggestion to fix vulnerability -'))
            console.log(chalk.magentaBright(printConsoleData[i].SuggestedMitigation))
        }

        var totalInstance = printConsoleData.length
        generateReport.printLinesToPDF(totalInstance, printConsoleData)
    }
}

function printData(index, vulnerabilityName, count, severity, vulnerabilityDetail, mitigation) {

    var data = {
        'VulnerabilityName': vulnerabilityName,
        'SeverityLevel': severity,
        'FoundInstance': count,
        'VulnerabilityDetails': vulnerabilityDetail,
        'SuggestedMitigation': mitigation
    }
    printConsoleData.push(data)

    var tdata = {
        'Vulnerability Name': vulnerabilityName,
        'Severity Level': severity,
        'Found Instance': count
    }
    tableData.push(tdata)
}